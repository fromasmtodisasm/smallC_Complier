%{
// @author : Shen Bingyu
// @date : 2015.11.01
// The syntax analysis part.

#include "node.h"
#include "includes.h"
using namespace std;

void yyerror(const char *s);
extern int yylex(void);
extern int yylineno; // get the line number
extern char* yytext; // get the token

Node* root;
%}

%union{
	Node* node;
	char* string;
}
%type <node> PROGRAM EXTDEFS EXTDEF EXTVARS SPEC STSPEC OPTTAG VAR FUNC PARAS PARASF PARA
%type <node> STMTBLOCK STMT ESTMT DEFS DEF DECS INIT FEXP EXP ARRS ARGS

%token <string> INT 
%token <string> ID
%token SEMI COMMA
%token <string> TYPE
%token <string> STRUCT
%token <string> RETURN IF ELSE BREAK CONT FOR
%token LC RC
%token <string> ASSIGNOP PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN DIV_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN SHL_ASSIGN SHR_ASSIGN LOGOR LOGAND BITOR BITXOR BITAND EQU NEQ GT LT GE LE SHL SHR PLUS MINUS MUL DIV MOD LOGNOT MINUSMINUS PLUSPLUS BITNOT LP RP LB RB DOT

%right ASSIGNOP PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN DIV_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN SHL_ASSIGN SHR_ASSIGN
%left LOGOR
%left LOGAND
%left BITOR
%left BITXOR
%left BITAND
%left EQU NEQ
%left GT LT GE LE
%left SHL SHR
%left PLUS MINUS
%left MUL DIV MOD
%right LOGNOT MINUSMINUS PLUSPLUS BITNOT
%left LP RP LB RB DOT



%start PROGRAM

%%
PROGRAM		: EXTDEFS 			{root = $$ = new Node(yylineno, Program, "PROGRAM",1,$1);}
		;
EXTDEFS		: EXTDEF EXTDEFS		{$$ = new Node(yylineno, Extdefs, "EXTDEFS", 2,$1,$2);}
		| /* empty */  			{$$ = new Node(yylineno, Null, "NULL", 2,$1,$2);}
		;
EXTDEF		: SPEC EXTVARS SEMI		{$$ = new Node(yylineno, Extdef, "EXTDEF", 2,$1,$2);}
		| SPEC FUNC STMTBLOCK		{$$ = new Node(yylineno, Extdef, "EXTDEF", 3,$1,$2,$3);}
		;
EXTVARS		: DEC				{$$ = new Node(yylineno, Extvars, "EXTVARS", 1,$1);}
		| DEC COMMA EXTVARS		{$$ = new Node(yylineno, Extvars, "EXTVARS", 2,$1,$3);}
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
SPEC 		: TYPE				{$$ = new Node(yylineno, Spec, "SPEC", 1, new Node(yylineno, Type, $1,0));}
		| STSPEC			{$$ = new Node(yylineno, Spec, "SPEC", 1,$1);}
		;
STSPEC		: STRUCT OPTTAG LC DEFS RC	{$$ = new Node(yylineno, Stspec, "STSPEC", 3,new Node(yylineno, Keyword, $1, 0), $2, $3);}
		| STRUCT ID			{$$ = new Node(yylineno, Stspec, "STSPEC", 2,new Node(yylineno, Keyword, $1, 0), new Node(yylineno, Id, $2,0));}
		;
OPTTAG		: ID				{$$ = new Node(yylineno, Opttag, "OPTTAG", 1,new Node(yylineno, Id, $1, 0));}	
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
VAR 		: ID				{$$ = new Node(yylineno, Var, "VAR", 1, new Node(yylineno, Id, $1, 0));}	
		| VAR LB INT RB			{$$ = new Node(yylineno, Var, "VAR", 2, $1, new Node(yylineno, Int, $3, 0));}	
		;
FUNC		: ID LP PARAS RP 		{$$ = new Node(yylineno, Func, "FUNC", 2, new Node(yylineno, Id, $1, 0), $3);}	
		;
PARAS		: PARASF			{$$ = new Node(yylineno, Paras, "PARAS", 1ï¼Œ$1);}	
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;	
PARASF		: PARA COMMA PARASF		{$$ = new Node(yylineno, Parasf, "PARASF", 2, $1, $3);}	
		| PARA				{$$ = new Node(yylineno, Parasg, "PARASF", 1, $1);}	
		;
PARA		: SPEC VAR			{$$ = new Node(yylineno, Para, "PARA", 2, $1, $2);}	
		;
STMTBLOCK	: LC DEFS STMTS RC		{$$ = new Node(yylineno, Stmtblock, "STMTBLOCK", 2, $2, $3);}	
		;
STMTS		: STMT STMTS			{$$ = new Node(yylineno, Stmts, "STMTS", 2, $1, $2);}	
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
STMT		: EXP SEMI			{$$ = new Node(yylineno, Stmt, "STMT", 1, $1);}	
		| STMTBLOCK			{$$ = new Node(yylineno, Stmt, "STMT", 1, $1);}
		| RETURN EXP SEMI		{$$ = new Node(yylineno, Stmt, "STMT", 2, new Node(yylineno, Keyword, $1, 0), $2);}
		| IF LP EXP RP STMT ESTMT	{$$ = new Node(yylineno, Stmt, "STMT", 4, new Node(yylineno, Keyword, $1, 0), $2, $5, $6);}
		| FOR LP FEXP SEMI FEXP SEMI EXP RP STMT 	{$$ = new Node(yylineno, Stmt, "STMT", 5, new Node(yylineno, Keyword, $1, 0), $3, $5, $7, $9);}
		| CONT SEMI			{$$ = new Node(yylineno, Stmt, "STMT", 1, new Node(yylineno, Keyword, $1, 0));}
		| BREAK SEMI			{$$ = new Node(yylineno, Stmt, "STMT", 1, new Node(yylineno, Keyword, $1, 0));}
		| READ LP EXP RP SEMI		{$$ = new Node(yylineno, Stmt, "STMT", 2, new Node(yylineno, Keyword, $1, 0), $3);}
		| WRITE LP EXP RP SEMI		{$$ = new Node(yylineno, Stmt, "STMT", 2, new Node(yylineno, Keyword, $1, 0), $3);}
		;
ESTMT		: ELSE STMT			{$$ = new Node(yylineno, Estmt, "ESTMT", 2, new Node(yylineno, Keyword, $1, 0), $2);}
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
DEFS		: DEF DEFS			{$$ = new Node(yylineno, Defs, "DEFS", 2, $1, $2);}
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
DEF		: SPEC DECS SEMI		{$$ = new Node(yylineno, Def, "DEF", 2, $1, $2);}
		;
DECS		: DEC COMMA DECS		{$$ = new Node(yylineno, Decs, "DECS", 2, $1, $3);}
		| DEC				{$$ = new Node(yylineno, Decs, "DECS", 1, $1);}
		;
DEC 		: VAR				{$$ = new Node(yylineno, Dec, "DEC", 1, $1);}
		| VAR ASSIGNOP INIT		{$$ = new Node(yylineno, Dec, "DEC", 3, $1, new Node(yylineno, Operator, $2, 0), $3);}
		;
INIT 		: EXP				{$$ = new Node(yylineno, Init, "INIT", 1, $1);}
		| LC ARGS RC			{$$ = new Node(yylineno, Init, "INIT", 1, $2);}
		;
FEXP:		:EXP
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
EXP 		: EXP MUL EXP
		| EXP DIV EXP
		| EXP MOD EXP
		| EXP PLUS EXP
		| EXP MINUS EXP
		| EXP SHL EXP
		| EXP SHR EXP
		| EXP GT EXP
		| EXP LT EXP
		| EXP GE EXP
		| EXP LE EXP
		| EXP EQU EXP
		| EXP NEQ EXP
		| EXP BITAND EXP
		| EXP BITOR EXP
		| EXP BITXOR EXP
		| EXP LOGAND EXP
		| EXP LOGOR EXP
		| EXP ASSIGNOP EXP
		| EXP PLUS_ASSIGN EXP
		| EXP MINUS_ASSIGN EXP
		| EXP MUL_ASSIGN EXP
		| EXP DIV_ASSIGN EXP
		| EXP AND_ASSIGN EXP
		| EXP XOR_ASSIGN EXP
		| EXP OR_ASSIGN EXP
		| EXP SHR_ASSIGN EXP
		| EXP SHL_ASSIGN EXP
////////////// UNARYOP    //////////
		| MINUS EXP %prec LOGNOT
		| LOGNOT EXP
		| BITNOT EXP
		| PLUSPLUS EXP
		| MINUSMINUS EXP
		| LP EXP RP
		| ID LP ARGS RP
		| ID ARRS
		| EXP DOT ID
		| INT
		;
ARRS 		: LB EXP RB ARRS
		| /* empty */			{$$ = new Node(yylineno, Null, "NULL", 0);}
		;
ARGS		: EXP COMMA ARGS
		| EXP
		; 
%%
void yyerror(const char *s) {
	fprintf(stderr, "[error] : %s. \n",s);
}

int main(int argc, char** argv) {
	if (argc != 2) {
		cout << "Parameter must be like <infile> <outfile>. \n";
		return -1;	
	}
		
	yyin = fopen(argv[1],"r");
	if(!yyin) {
		perror(argv[1]);
		return -2;
	}
	yyout = freopen(argv[2], "w+", stdout);
	yyparse();
	fclose(yyin);
	fclose(yyout);
	return 0;
}
